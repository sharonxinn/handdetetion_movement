<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Heart Particle Demo</title>
<style>
body { margin:0; padding:0; width:100vw; height:100vh; overflow:hidden; display:flex; justify-content:center; align-items:center; background-color:transparent; }
.wrapper { position:relative; width:100%; height:100%; overflow:hidden; }
#videoEl { position:absolute; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
#drawCanvas { position:absolute; top:0; left:0; width:100%; height:100%; transform:scaleX(-1); pointer-events:none; }
#threeDiv { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5; }
#info { position:absolute; top:20px; left:20px; color:#fff; background-color:rgba(0,0,0,0.5); padding:10px; border-radius:5px; font-family:Arial,sans-serif; z-index:10; }
</style>
</head>
<body>
<div class="wrapper">
    <video id="videoEl" autoplay playsinline></video>
    <canvas id="drawCanvas"></canvas>
    <div id="threeDiv"></div>
    <div id="info">Loading...</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded',()=>{

const vid=document.getElementById('videoEl');
const canvas=document.getElementById('drawCanvas');
const ctx=canvas.getContext('2d');
const status=document.getElementById('info');
const threeWrapper=document.getElementById('threeDiv');

let scene3,camera3,renderer3;
let leftSmall,leftLarge,rightSmall,rightLarge;
let leftSmallPts=[], leftLargePts=[], rightSmallPts=[], rightLargePts=[];

function resizeCanvas(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
function setupLayout(){ resizeCanvas(); }
window.addEventListener('resize',()=>{ setupLayout(); if(renderer3){renderer3.setSize(window.innerWidth,window.innerHeight);} if(camera3){camera3.aspect=window.innerWidth/window.innerHeight; camera3.updateProjectionMatrix();} });
setupLayout();

async function initCamera(){
    const stream=await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1920},height:{ideal:1080},facingMode:'user'}});
    vid.srcObject=stream;
    return new Promise(res=>{vid.onloadedmetadata=()=>{setupLayout(); res(vid);};});
}

function generateHeartParticles(num, scaleRange, depth=0.2, colors=[0xff69b4,0xff1493]){
    const geo=new THREE.BufferGeometry();
    const posArr=[];
    const colArr=[];
    const dataArr=[];
    for(let i=0;i<num;i++){
        const t=Math.random()*Math.PI*2;
        const s=scaleRange[0]+Math.random()*(scaleRange[1]-scaleRange[0]);
        const x=s*16*Math.pow(Math.sin(t),3);
        const y=s*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
        const z=(Math.random()-0.5)*depth;
        posArr.push(x*0.1,y*0.1,z);
        const c=new THREE.Color(colors[Math.floor(Math.random()*colors.length)]);
        colArr.push(c.r,c.g,c.b);
        dataArr.push({bx:x*0.1,by:y*0.1,bz:z,ang:Math.random()*Math.PI*2,radius:Math.random()*0.05});
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(posArr,3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(colArr,3));
    return {geo,dataArr};
}

function initThree(){
    scene3=new THREE.Scene();
    camera3=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
    camera3.position.z=10;
    renderer3=new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer3.setSize(window.innerWidth,window.innerHeight);
    renderer3.setClearColor(0x000000,0);
    threeWrapper.appendChild(renderer3.domElement);

    const leftInner=generateHeartParticles(1200,[0.6,1.0],0.3);
    leftSmallPts=leftInner.dataArr;
    leftSmall=new THREE.Points(leftInner.geo,new THREE.PointsMaterial({vertexColors:true,size:0.08,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending}));
    leftSmall.position.x=-9;
    scene3.add(leftSmall);

    const leftOuter=generateHeartParticles(4000,[1.4,2.5],0.5);
    leftLargePts=leftOuter.dataArr;
    leftLarge=new THREE.Points(leftOuter.geo,new THREE.PointsMaterial({vertexColors:true,size:0.06,transparent:true,opacity:0.5,blending:THREE.AdditiveBlending}));
    leftLarge.position.x=-9;
    scene3.add(leftLarge);

    const rightInner=generateHeartParticles(1200,[0.6,1.0],0.3);
    rightSmallPts=rightInner.dataArr;
    rightSmall=new THREE.Points(rightInner.geo,new THREE.PointsMaterial({vertexColors:true,size:0.08,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending}));
    rightSmall.position.x=6;
    scene3.add(rightSmall);

    const rightOuter=generateHeartParticles(4000,[1.4,2.5],0.5);
    rightLargePts=rightOuter.dataArr;
    rightLarge=new THREE.Points(rightOuter.geo,new THREE.PointsMaterial({vertexColors:true,size:0.06,transparent:true,opacity:0.5,blending:THREE.AdditiveBlending}));
    rightLarge.position.x=6;
    scene3.add(rightLarge);

    tick();
}

function tick(){
    requestAnimationFrame(tick);
    let arr,pos;

    pos=leftSmall.geometry.attributes.position.array;
    for(let i=0;i<leftSmallPts.length;i++){ const idx=i*3,p=leftSmallPts[i],o=Math.sin(Date.now()*0.002+p.ang)*p.radius; pos[idx]=p.bx+o; pos[idx+1]=p.by+o; pos[idx+2]=p.bz+o;}
    leftSmall.geometry.attributes.position.needsUpdate=true;

    pos=leftLarge.geometry.attributes.position.array;
    for(let i=0;i<leftLargePts.length;i++){ const idx=i*3,p=leftLargePts[i],o=Math.sin(Date.now()*0.002+p.ang)*p.radius; pos[idx]=p.bx+o; pos[idx+1]=p.by+o; pos[idx+2]=p.bz+o;}
    leftLarge.geometry.attributes.position.needsUpdate=true;

    pos=rightSmall.geometry.attributes.position.array;
    for(let i=0;i<rightSmallPts.length;i++){ const idx=i*3,p=rightSmallPts[i],o=Math.sin(Date.now()*0.002+p.ang)*p.radius; pos[idx]=p.bx+o; pos[idx+1]=p.by+o; pos[idx+2]=p.bz+o;}
    rightSmall.geometry.attributes.position.needsUpdate=true;

    pos=rightLarge.geometry.attributes.position.array;
    for(let i=0;i<rightLargePts.length;i++){ const idx=i*3,p=rightLargePts[i],o=Math.sin(Date.now()*0.002+p.ang)*p.radius; pos[idx]=p.bx+o; pos[idx+1]=p.by+o; pos[idx+2]=p.bz+o;}
    rightLarge.geometry.attributes.position.needsUpdate=true;

    renderer3.render(scene3,camera3);
}

function dist3(p1,p2){ const dx=p1.x-p2.x, dy=p1.y-p2.y, dz=(p1.z||0)-(p2.z||0); return Math.sqrt(dx*dx+dy*dy+dz*dz); }

async function setupHands(){
    status.textContent='Loading hands...';
    const hands=new Hands({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands:2,modelComplexity:1,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
    await hands.initialize();
    status.textContent='Hands ready';
    return hands;
}

function drawHand(lms,left){
    const sz=Math.min(window.innerWidth,window.innerHeight);
    const lw=Math.max(2,Math.min(5,sz/300));
    const ps=Math.max(2,Math.min(8,sz/250));
    const conns=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[0,5],[5,9],[9,13],[13,17]];
    const col=left?'#00FF00':'#00FFFF';
    ctx.lineWidth=lw;
    ctx.strokeStyle=col;
    conns.forEach(([i,j])=>{ const s=lms[i], e=lms[j]; ctx.beginPath(); ctx.moveTo(s.x*canvas.width,s.y*canvas.height); ctx.lineTo(e.x*canvas.width,e.y*canvas.height); ctx.stroke(); });
    lms.forEach((lm,idx)=>{ let pc=(idx===4||idx===8)?'#FF0000':col; ctx.fillStyle=pc; ctx.beginPath(); ctx.arc(lm.x*canvas.width,lm.y*canvas.height,ps*1.2,0,2*Math.PI); ctx.fill(); });
}

function processHands(results){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(canvas.width!==window.innerWidth||canvas.height!==window.innerHeight) resizeCanvas();
    if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
        status.textContent=results.multiHandLandmarks.length===1?'1 hand detected':`${results.multiHandLandmarks.length} hands detected`;
        for(let i=0;i<results.multiHandLandmarks.length;i++){
            const lm=results.multiHandLandmarks[i];
            const handLabel=results.multiHandedness[i].label;
            const leftHand=handLabel==='Left';
            drawHand(lm,leftHand);

            if(!leftHand){
                const t=lm[4], ind=lm[8];
                const pd=dist3(t,ind);
                const sMin=0.9,sMax=1.2,oMin=0.8,oMax=1.0;
                let sScale=sMin + (pd-0.05)*(sMax-sMin)/(0.25-0.05);
                sScale=Math.min(sMax,Math.max(sMin,sScale));
                let oScale=oMax-(sScale-sMin)*(oMax-oMin)/(sMax-sMin);
                oScale=Math.min(oMax,Math.max(oMin,oScale));
                leftSmall.scale.set(sScale,sScale,sScale);
                leftLarge.scale.set(oScale,oScale,oScale);
                rightSmall.scale.set(sScale,sScale,sScale);
                rightLarge.scale.set(oScale,oScale,oScale);
            }
        }
    } else { status.textContent='No hands detected'; }
}

async function runApp(){
    try{
        await initCamera();
        initThree();
        const hands=await setupHands();
        hands.onResults(processHands);
        const camMP=new Camera(vid,{onFrame:async()=>{await hands.send({image:vid});}, width:1920,height:1080});
        camMP.start();
    }catch(e){ status.textContent=`Error: ${e.message}`; console.error(e);}
}

runApp();
});
</script>
</body>
</html>